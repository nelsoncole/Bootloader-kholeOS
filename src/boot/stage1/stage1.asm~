; "stage1.asm"
;
; "Projecto KholeOS. Bootloader" 
; Nelson Sapalo da Silva Cole (nelsoncole72@gmail.com  +244-948-833-132)
; Lubango 16 de Julho de 2017
;
;
;
;
;
;
;
; Vamos inicializar com o FAT32



bits 16			; diz ao nosso nasm que usaremos endereçamento de 16 -bits
org 0x7c00		; nosso offset
main: jmp start		; char BS_jmpBoot[3]		;2-0

	
	BS_OEMName DB "KHOLE OS"	;10-3	char [8] 
	BPB_BytsPerSec DW 512		;12-11
	BPB_SecPerClus DB 8		;13
	BPB_RsvdSecCnt DW 0x20		;15-14
	BPB_NumFATs DB 1		;16
	BPB_RootEntCnt DW 0		;18-17 Em FAT32 valor e sempre 0
	BPB_TotSec16 DW 0		;20-19   se o valor for zero significa que temos mais de 65535
	BPB_Media DB 0			;21
	BPB_FATSz16 DW 0		;23-22
	BPB_SecPertrk DW 0		;25-24
	BPB_NumHeads DW 0		;27-26
	BPB_HiddSec DD 0		;31-28
	BPB_TotSec32 DD 0		;35-32

; Aqui teremos Ext. BPB struture for FAT32 	
	BPB_FATSz32 DD 0		;39-36
	BPB_ExtFlags DW 0		;41-40
	BPB_FSVer DW 0			;43-42
	BPB_RootClus DD 0x2		;47-44
	BPB_FSInfo DW 1			;49-48
	BPB_BkBootSec DW 0x6		;51-50
	BPB_Reserved: times 12 db 0	;63-52
	BS_DrvNum DB 0			;64
	BS_Reserved1 DB 0		;65
	BS_BootSig DB 0x29			;66
	BS_VolID DD 0			;70-67
	BS_VolLab DB "NO NAME    "	;91-71, sao char[11]
	BS_FilSysType DB "FAT32   "	;89-82, sao char[8]


; Algumas variaveis

FirstDataSector DD 0


Name_stage2 db "stage2",0,0
Name_ext db "bin"

bootSig db "Lubango!"  

msg1 db "[ Erro ao ler sector ... ]",0
msg2 db "[ No boot ... ]",0


start:
	cli		; desabilita interrupções
	xor ax,ax	; zera ax
	mov ds,ax	; ds igual a 0
	mov es,ax	; es igual a 0
	mov ss,ax	; ss igual a 0
	mov sp,0x1000	; 4KB, pilha
	sti		; habilita interrupções


	mov BYTE [BS_DrvNum],dl

; Define o modo de vídeo, modo texto color

	mov ax,3
	int 0x10




; Detetando o 1 sector de dados FirstDataSector

	mov eax,DWORD[BPB_FATSz32]
	movzx ebx,BYTE [BPB_NumFATs]
	mul ebx
	movzx ebx,WORD[BPB_RsvdSecCnt]
	add eax,ebx

	mov DWORD [FirstDataSector],eax
	

	

; Lendo o Root Directory. FirstSectorOfCluster  (N-2)

	mov eax,DWORD[BPB_RootClus]
	sub eax,2
	movzx ebx,BYTE[BPB_SecPerClus]
	mul ebx
	add eax,DWORD [FirstDataSector]

; Carregando o claster na memorio do Directory/File
	xor cx,cx
	mov cl,BYTE[BPB_SecPerClus]
	xor di,di
	mov bx,0x7E00
	call read_sectors

; Analizar as entradas, cada entrada tem 32 bytes

	xor eax,eax
	xor ebx,ebx
	xor cx,cx

	mov ax,WORD[BPB_BytsPerSec]
	mov bl,BYTE[BPB_SecPerClus]
	mul bx
	
	xor edx,edx
	mov bx,32
	div bx

	xchg cx,ax
	lea bx,[0x7E00]

	
; Aqui vamos nalizar todas as entradas no Root Dir ate achar o arquivo de nome 8.3 "stage2.bin"
	

.goto_1: 
	cmp BYTE [bx],0	;Se for 0 entrada nao usada
	je .goto_3
	cmp BYTE [bx+11],0x20	; Se for 0x20 arquivo de nome 8.3
	jne .goto_3

	mov cx,8
	lea di,[bx]
	mov si,Name_stage2
	rep cmpsb
	jne .goto_3
	
	mov cx,3
	lea di,[bx+8]
	mov si,Name_ext
	rep cmpsb
	jne .goto_3
	jmp .arquivo_encontrado
	


.goto_3:
	dec cx	
	jcxz .arquivo_nao_encontrado
	add bx,32
	jmp .goto_1


.arquivo_nao_encontrado:	
	mov si,msg2
	call puts

	xor ax,ax
	int 0x16
	int 0x19
	

.arquivo_encontrado:

	
; Lendo o stage2.bin

	movzx eax, WORD [bx + 26]
	sub eax,2
	movzx ecx,BYTE[BPB_SecPerClus]
	mul ecx
	xchg esi,eax


	xor eax,eax
	xor ebx,ebx
	
	mov ax,WORD [BPB_BytsPerSec]
	mov cl,BYTE [BPB_SecPerClus]
	mul cx

	xor edx,edx
	xchg ecx,eax
	mov eax,DWORD[bx + 28]
	div ecx
	
	xchg eax,ecx
	mov eax,esi
	add eax,DWORD[FirstDataSector]
	mov di,0x0800
	xor bx,bx
	call read_sectors



	xor dx,dx
	mov dl,BYTE[BS_DrvNum]
	push dx			; empura dl na pilha
	jmp 0x0000:0x8000	; Executa o segundo estágio



	
erro:
; desempilha todos registradores de uso geral
	popa

	mov si,msg1
	call puts

	xor ax,ax
	int 0x16
	int 0x19	; reboot



; Função imprime string na tela

puts:
	pusha		; empilha todos os registradores de uso geral
.next:
	cld 		; flag de direcção
	lodsb		; a cada loop carrega si p --> al, actualizando si
	cmp al,0	; compara al com o 0
	je  .end	; se al for 0 pula para o final do programa	
	mov ah,0x0e	; função TTY da BIOS imprime caracter na tela
	int 0x10	; interrupção de vídeo
	jmp .next	; próximo caracter
.end:
	popa	; desempilha todos os registradores de uso geral
	ret	; retorna






read_sectors:
	; cx --> count
	; di --> Segmento
	; bx --> Offset
	; eax --> Starting sector LBA47
	


.loop:
	pusha
	mov [si+0], BYTE 0x10	; Tamanho da DAP
	mov [si+1], BYTE 0	; reservado
	mov [si+2], WORD 1	; Sector count
	mov [si+4], bx		; Offset
	mov [si+6], di		; Segment
	mov [si+8], eax		; Start sector LBA47
	mov [si+12], DWORD 0	; Starting sector LBA47
	mov dl,BYTE[BS_DrvNum]
	mov ah,0x42
	int 0x13
	jc erro		
	popa
	
	dec cx
	jcxz .end	
	add bx,0x200
	cmp bx,0xFFFF		; 64KB
	jne .goto_1
	add di,0x1000		; 4 KB
	xor bx,bx
.goto_1:
	inc eax
	jmp .loop
.end:
	
	ret



times 512-2 - ($-$$) db 0		; esta rotina fará com que o código tenha 512 Bytes - os 2
					; últimos Bytes da assinatura 
dw 0xaa55	; Assinatura de boot
